{"version":3,"sources":["../src/KafkaMessageFactory.ts"],"names":[],"mappings":";;AAAA,IAAY,iBAMX;AAND,WAAY,iBAAiB;IACzB,8CAAyB,CAAA;IACzB,kCAAa,CAAA;IACb,gCAAW,CAAA;IACX,wCAAmB,CAAA;IACnB,wCAAmB,CAAA;AACvB,CAAC,EANW,iBAAiB,GAAjB,yBAAiB,KAAjB,yBAAiB,QAM5B;AAUD;IAYI;QATQ,gBAAW,GAAiB,EAAE,CAAC;IAUvC,CAAC;IARM,MAAM,KAAK,QAAQ;QACtB,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE;YAChC,mBAAmB,CAAC,SAAS,GAAG,IAAI,mBAAmB,EAAE,CAAC;SAC7D;QACD,OAAO,mBAAmB,CAAC,SAAS,CAAC;IACzC,CAAC;IAKO,WAAW,CAAC,QAAgB;QAChC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE;YAC7B,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG;gBACzB,eAAe,EAAE,EAAE;gBACnB,aAAa,EAAE,EAAE;aACpB,CAAC;SACL;QACD,OAAO,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;IACtC,CAAC;IAEO,iBAAiB,CAAI,QAAgB,EAAE,WAAmB,EAAE,SAAmC;QACnG,MAAM,aAAa,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,aAAa,CAAC;QAC/D,aAAa,CAAC,WAAW,CAAC,GAAG,SAAS,CAAC;IAC3C,CAAC;IAEO,uBAAuB,CAAC,QAAgB,EAAE,WAAmB,EAAE,eAAkC;QACrG,MAAM,eAAe,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,eAAe,CAAC;QACnE,IAAI,CAAC,eAAe,CAAC,eAAe,CAAC,EAAE;YACnC,eAAe,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC;SACzC;QACD,eAAe,CAAC,eAAe,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IACvD,CAAC;IAEM,YAAY,CAAI,QAAgB,EAAE,WAAmB;QACxD,MAAM,aAAa,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,aAAa,CAAC;QAC/D,OAAO,aAAa,CAAC,WAAW,CAAC,CAAC;IACtC,CAAC;IAEM,eAAe,CAAC,QAAgB,EAAE,QAA2B;QAChE,MAAM,eAAe,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,eAAe,CAAC;QACnE,OAAO,eAAe,CAAC,QAAQ,CAAC,CAAC;IACrC,CAAC;IAEM,oBAAoB,CAAI,QAAgB,EAAE,WAAmB,EAChE,eAAkC,EAAE,SAAmC;QACvE,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;QACzD,IAAI,CAAC,uBAAuB,CAAC,QAAQ,EAAE,WAAW,EAAE,eAAe,CAAC,CAAC;IACzE,CAAC;IAEM,sBAAsB,CAAC,cAK5B;QACE,cAAc,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE,CAClC,IAAI,CAAC,oBAAoB,CACrB,YAAY,CAAC,QAAQ,EACrB,YAAY,CAAC,WAAW,EACxB,YAAY,CAAC,eAAe,EAC5B,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC;IACrC,CAAC;CACJ;AAnED,sCAmEC","file":"KafkaMessageFactory.js","sourcesContent":["export enum MessageCategories {\n    NeedFilter = 'NeedFilter',\n    Need = 'Need',\n    Bid = 'Bid',\n    Mission = 'Mission',\n    Message = 'Message',\n}\n\ninterface IClassTypesMap { [messageType: string]: new (...all: any[]) => any; }\ninterface IMessageTypesMap { [messageCategory: string]: string[]; }\ninterface IProtocolMapEntry {\n    classTypesMap: IClassTypesMap;\n    messageTypesMap: IMessageTypesMap;\n}\ninterface IProtocolMap { [protocol: string]: IProtocolMapEntry; }\n\nexport default class KafkaMessageFactory {\n    private static _instance: KafkaMessageFactory;\n\n    private protocolMap: IProtocolMap = {};\n\n    public static get instance(): KafkaMessageFactory {\n        if (!KafkaMessageFactory._instance) {\n            KafkaMessageFactory._instance = new KafkaMessageFactory();\n        }\n        return KafkaMessageFactory._instance;\n    }\n\n    private constructor() {\n    }\n\n    private getProtocol(protocol: string): IProtocolMapEntry {\n        if (!this.protocolMap[protocol]) {\n            this.protocolMap[protocol] = {\n                messageTypesMap: {},\n                classTypesMap: {},\n            };\n        }\n        return this.protocolMap[protocol];\n    }\n\n    private registerClassType<T>(protocol: string, messageType: string, classType: new (...all: any[]) => T): void {\n        const classTypesMap = this.getProtocol(protocol).classTypesMap;\n        classTypesMap[messageType] = classType;\n    }\n\n    private registerMessageCategory(protocol: string, messageType: string, messageCategory: MessageCategories): void {\n        const messageTypesMap = this.getProtocol(protocol).messageTypesMap;\n        if (!messageTypesMap[messageCategory]) {\n            messageTypesMap[messageCategory] = [];\n        }\n        messageTypesMap[messageCategory].push(messageType);\n    }\n\n    public getClassType<T>(protocol: string, messageType: string): new (...all: any[]) => T {\n        const classTypesMap = this.getProtocol(protocol).classTypesMap;\n        return classTypesMap[messageType];\n    }\n\n    public getMessageTypes(protocol: string, category: MessageCategories): string[] {\n        const messageTypesMap = this.getProtocol(protocol).messageTypesMap;\n        return messageTypesMap[category];\n    }\n\n    public registerMessageClass<T>(protocol: string, messageType: string,\n        messageCategory: MessageCategories, classType: new (...all: any[]) => T): void {\n        this.registerClassType(protocol, messageType, classType);\n        this.registerMessageCategory(protocol, messageType, messageCategory);\n    }\n\n    public registerMessageClasses(messageClasses: Array<{\n        protocol: string,\n        messageType: string,\n        messageCategory: MessageCategories,\n        classType: new (...all: any[]) => any,\n    }>): void {\n        messageClasses.forEach(messageClass =>\n            this.registerMessageClass(\n                messageClass.protocol,\n                messageClass.messageType,\n                messageClass.messageCategory,\n                messageClass.classType));\n    }\n}\n"]}