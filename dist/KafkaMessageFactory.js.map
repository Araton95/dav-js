{"version":3,"sources":["../src/KafkaMessageFactory.ts"],"names":[],"mappings":";;AAAA,IAAY,iBAMX;AAND,WAAY,iBAAiB;IAC3B,8CAAyB,CAAA;IACzB,kCAAa,CAAA;IACb,gCAAW,CAAA;IACX,wCAAmB,CAAA;IACnB,wCAAmB,CAAA;AACrB,CAAC,EANW,iBAAiB,GAAjB,yBAAiB,KAAjB,yBAAiB,QAM5B;AAgBD;IAYE;QATQ,gBAAW,GAAiB,EAAE,CAAC;IAShB,CAAC;IAPjB,MAAM,KAAK,QAAQ;QACxB,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE;YAClC,mBAAmB,CAAC,SAAS,GAAG,IAAI,mBAAmB,EAAE,CAAC;SAC3D;QACD,OAAO,mBAAmB,CAAC,SAAS,CAAC;IACvC,CAAC;IAIO,WAAW,CAAC,QAAgB;QAClC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE;YAC/B,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG;gBAC3B,eAAe,EAAE,EAAE;gBACnB,aAAa,EAAE,EAAE;aAClB,CAAC;SACH;QACD,OAAO,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;IACpC,CAAC;IAEO,iBAAiB,CACvB,QAAgB,EAChB,WAAmB,EACnB,SAAmC;QAEnC,MAAM,aAAa,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,aAAa,CAAC;QAC/D,aAAa,CAAC,WAAW,CAAC,GAAG,SAAS,CAAC;IACzC,CAAC;IAEO,uBAAuB,CAC7B,QAAgB,EAChB,WAAmB,EACnB,eAAkC;QAElC,MAAM,eAAe,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,eAAe,CAAC;QACnE,IAAI,CAAC,eAAe,CAAC,eAAe,CAAC,EAAE;YACrC,eAAe,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC;SACvC;QACD,eAAe,CAAC,eAAe,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IACrD,CAAC;IAEM,YAAY,CACjB,QAAgB,EAChB,WAAmB;QAEnB,MAAM,aAAa,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,aAAa,CAAC;QAC/D,OAAO,aAAa,CAAC,WAAW,CAAC,CAAC;IACpC,CAAC;IAEM,eAAe,CACpB,QAAgB,EAChB,QAA2B;QAE3B,MAAM,eAAe,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,eAAe,CAAC;QACnE,OAAO,eAAe,CAAC,QAAQ,CAAC,CAAC;IACnC,CAAC;IAEM,oBAAoB,CACzB,QAAgB,EAChB,WAAmB,EACnB,eAAkC,EAClC,SAAmC;QAEnC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;QACzD,IAAI,CAAC,uBAAuB,CAAC,QAAQ,EAAE,WAAW,EAAE,eAAe,CAAC,CAAC;IACvE,CAAC;IAEM,sBAAsB,CAC3B,cAKE;QAEF,cAAc,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE,CACpC,IAAI,CAAC,oBAAoB,CACvB,YAAY,CAAC,QAAQ,EACrB,YAAY,CAAC,WAAW,EACxB,YAAY,CAAC,eAAe,EAC5B,YAAY,CAAC,SAAS,CACvB,CACF,CAAC;IACJ,CAAC;CACF;AAxFD,sCAwFC","file":"KafkaMessageFactory.js","sourcesContent":["export enum MessageCategories {\n  NeedFilter = 'NeedFilter',\n  Need = 'Need',\n  Bid = 'Bid',\n  Mission = 'Mission',\n  Message = 'Message',\n}\n\ninterface IClassTypesMap {\n  [messageType: string]: new (...all: any[]) => any;\n}\ninterface IMessageTypesMap {\n  [messageCategory: string]: string[];\n}\ninterface IProtocolMapEntry {\n  classTypesMap: IClassTypesMap;\n  messageTypesMap: IMessageTypesMap;\n}\ninterface IProtocolMap {\n  [protocol: string]: IProtocolMapEntry;\n}\n\nexport default class KafkaMessageFactory {\n  private static _instance: KafkaMessageFactory;\n\n  private protocolMap: IProtocolMap = {};\n\n  public static get instance(): KafkaMessageFactory {\n    if (!KafkaMessageFactory._instance) {\n      KafkaMessageFactory._instance = new KafkaMessageFactory();\n    }\n    return KafkaMessageFactory._instance;\n  }\n\n  private constructor() {}\n\n  private getProtocol(protocol: string): IProtocolMapEntry {\n    if (!this.protocolMap[protocol]) {\n      this.protocolMap[protocol] = {\n        messageTypesMap: {},\n        classTypesMap: {},\n      };\n    }\n    return this.protocolMap[protocol];\n  }\n\n  private registerClassType<T>(\n    protocol: string,\n    messageType: string,\n    classType: new (...all: any[]) => T,\n  ): void {\n    const classTypesMap = this.getProtocol(protocol).classTypesMap;\n    classTypesMap[messageType] = classType;\n  }\n\n  private registerMessageCategory(\n    protocol: string,\n    messageType: string,\n    messageCategory: MessageCategories,\n  ): void {\n    const messageTypesMap = this.getProtocol(protocol).messageTypesMap;\n    if (!messageTypesMap[messageCategory]) {\n      messageTypesMap[messageCategory] = [];\n    }\n    messageTypesMap[messageCategory].push(messageType);\n  }\n\n  public getClassType<T>(\n    protocol: string,\n    messageType: string,\n  ): new (...all: any[]) => T {\n    const classTypesMap = this.getProtocol(protocol).classTypesMap;\n    return classTypesMap[messageType];\n  }\n\n  public getMessageTypes(\n    protocol: string,\n    category: MessageCategories,\n  ): string[] {\n    const messageTypesMap = this.getProtocol(protocol).messageTypesMap;\n    return messageTypesMap[category];\n  }\n\n  public registerMessageClass<T>(\n    protocol: string,\n    messageType: string,\n    messageCategory: MessageCategories,\n    classType: new (...all: any[]) => T,\n  ): void {\n    this.registerClassType(protocol, messageType, classType);\n    this.registerMessageCategory(protocol, messageType, messageCategory);\n  }\n\n  public registerMessageClasses(\n    messageClasses: Array<{\n      protocol: string;\n      messageType: string;\n      messageCategory: MessageCategories;\n      classType: new (...all: any[]) => any;\n    }>,\n  ): void {\n    messageClasses.forEach(messageClass =>\n      this.registerMessageClass(\n        messageClass.protocol,\n        messageClass.messageType,\n        messageClass.messageCategory,\n        messageClass.classType,\n      ),\n    );\n  }\n}\n"]}